# Day06

## Garbage Collector

### 垃圾的概念

    没有引用的对象

### 如何找到垃圾

- Reference Count, 引用计数算法，一个对象被引用的次数为 n, 当 n 为0时，表示该对象为垃圾，但是此算法无法处理循环引用的情况

- Root Searching, 根可达算法，通过程序启动的根对象去找，找不到的为垃圾
  1. 线程栈变量
  2. 静态变量
  3. 常量池
  4. JNI指针

### 如何清除

- Mark Sweep, 标记清除：适用于存活对象比较多的场景，需要经两边扫描，第一遍进行标记，第二遍进行清除，容易产生碎片🧩

- Copying, 拷贝算法：找到存活对象，复制到另一块内存中。适用于存活对象较少的场景，需要一遍扫描，不会产生碎片，但需要复制对象，调整对象引用

- Mark Compact，标记压缩：适用于存活对象比较多的场景，将存活对象整理到一起，在内存起始位置。不会产生碎片。第一次扫描找到存活对象，第二次扫描移动对象

### 堆内存的逻辑分区（分代垃圾收集器）

｜  <--  8  -->  |  <-- 1 -->  |  <-- 1 -->   |
｜  <-- 伊甸 --> | <-survivor-> |<--survivor-->| <-- old(老年代) --> ｜
｜  <--               新生代 33%           --> |  <-- 老年代 66% -->  |
> 新生代存活数量少，采用 Copying 算法，老年代存活对象数量多，对象多次回收都没有回收 ，采用 Mark Sweep 或者 Mark Compact。当分区满了的时候，就会触发相应的回收

### 一个新的对象分配

- 首先如果栈上空间足够，分配在栈上(开启逃逸分析)
- 栈上空间不足，分配在伊甸区，每个线程占有伊甸区 1% 的空间，首先分配在此空间（TLAB 线程本地分配）

### 常见的垃圾回收器

> 第一个回收年轻代，第二个回收老年代

- Serial + Serial Old: 单线程的垃圾回收机制，当开始回收的时候，工作线程将会停止工作

- Parallel Scavenge + Parallel Old: 默认的 JVM 垃圾回收器，多线程的垃圾回收机制，工作线程将会停止

- ParNew + CMS: ParNew 同 Parallel Scavenge，添加了同 CMS 一共工作的功能

### CMS （concurrent Mark Sweep）

> 并发回收，回收的线程不会阻塞工作线程，并行处理。解决 STW 问题

- 阶段：

1. 初始标记：STW，只标记根对象。单线程
2. 并发标记：和工作线程并发标记垃圾，多线程。耗费大多数时间。期间产生的新的垃圾由下一个阶段处理
3. 重新标记：STW，标记‘并发标记’中产生的垃圾
4. 并发清理：和工作线程并发执行最后的清理工作。期间产生的垃圾为 浮动垃圾，待下次 CMS 处理

- 缺点

1. 采用标记清除算法，会使内存碎片化，转化成 Serial Old
2. 产生浮动垃圾

- 解决办法
