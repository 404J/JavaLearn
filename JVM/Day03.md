# Day03

## Java 内存模型

### 硬件层的并发优化: 数据一致性

- 总线锁 -> 保证每个线程的内存中变量的值和主内存一致

- MESI 协议

- 缓存行为不同线程 CPU 内存从 主内存读取数据的单位。如果两个变量位于同一个缓存行，不同线程间就需要维护其他未使用的变量，形成伪共享，会影响效率。缓存行对齐，可以提高效率

  ```java
  code
  ```

- CPU 指令的乱序执行
  指令间如果没有依赖关系，指令不一定会顺序执行

  ```java
  code
  ```

- CPU 合并写
  CPU 将同一个数据的多个计算结果合并成一次写到缓存的操作

- CPU 内存屏障
  使得指令通过一定顺序执行

### volatile 实现内存屏障

  1. 字节码层面：加了一个标记 ACC_VOLATILE

  2. JVM 层面：JVM 对于 volatile 修饰的变量的读写操作都加了内存屏障，不允许指令重排序

  3. OS 和硬件层面：省略

### synchronized 实现方法

  1. 字节码层面：monitorenter / monitorexit

  2. JVM 层面：使用 C 语言

  3. 硬件层面：lock 指令实现
